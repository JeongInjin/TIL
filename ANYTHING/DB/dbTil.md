#Index

* Index 란 (https://rebro.kr/167)
  * <b>데이터베이스의 테이블에 대한 검색 속도를 향상시켜주는 자료구조</b> 이다.
  * 테이블의 특정 컬럼(Column)에 인덱스를 생성하면, 해당 컬럼의 데이터를 정렬한 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 
    * 컬럼의 값과 물리적 주소를 (key, value)의 한 쌍으로 저장한다.

* 장점
  * 검색 속도와 성능 향상. -> 시스템이 전반적인 부하가 줄어든다.
* 단점
  * 인덱스를 관리하기 위한 추가 작업 필요
  * 추가 저장 공간 필요
  * 잘못 사용하는 경우 오히려 검색 성능 저하
  * 
  
* 인덱스를 사용하면 좋은 경우
  * 규모가 큰 테이블
  * 삽입, 수정, 삭제 작업이 자주 발생하지 않는 칼럼
  * where, order by, join 등이 자주 사용되는 컬럼
  * 데이터의 중복도가 낮은 컬럼
  
* 인덱스의 자료구조
  * 해시테이블
  * B+ Tree
  

#테이블 유지관리
* 테이블 유지관리를 수행하기 위한 Sql 문
  * ANALYZE TABLE: 인덱스 통계 업데이트
  * CHECK TABLE: 무결성을 제대로 확인
  * CHECKSUM TABLE: 무결성을 제대로 확인
  * REPAIR TABLE: 수리
  * OPTIMIZE TABLE: 최적화
  * mysql> CHECK TABLE world_innodb.City;  
  +-------------------+-------+----------+----------+  
  | Table             | Op    | Msg_type | Msg_text |  
  +-------------------+-------+----------+----------+  
  | world_innodb.City | check | status   | OK       |  
  +-------------------+-------+----------+----------+  
  * Table: 작업이 수행된 테이블을 나타냅니다.
  * Op: 작업 이름 지정(확인, 수리, 분석 또는 최적화)
  * Msg_type: 성공 또는 실패의 지표 제공
  * Msg_text: 추가 정보 제공


#Sql 최적화 기본
[옵티마이저와 실행계획]
* 옵티마이저(Optimizer) 개념
  * SQL 은 사용자의 요구사항만 기술할 뿐 처리 과정은 기술하지 않음
    * 실제로 SQL문을 실행하기 <b>전</b>에 최적의 실행계획을 찾아야 함
  * 옵티마이저: 사용자의 요구사항을 만족하는 다향한 실행계획(Execution Plan) 중 최족의 실행계획을 결정
    * SQL 을 어떤 순서로 어떻게 실행할지 결정하는 작업 수행
* 옵티마이저 종류
  * 규칙기반 옵티마이저(RBO: Role-Based Optimizer)
    * 거의 사용하지 않지만, 하위 버전 호환성을 위해 유지
  * 비용기반 옵티마이저(CBO: Cost-Based Optimizer)

- 비용기반 옵티마이저
  - 규칙기반 옵티마이저의 한계를 극복하고
    - 몇 개의 규칙만으로는 현실의 모든 상황을 설명하기 어려움
    - ex) 항상 '=' 이 BETWEEN 보다 빠른가?
  - SQL 문 처리에 예상되는 비용(소요시간, 자원사용량)을 최소하하기 위한 방법 필요
  - 테이블, 인덱스, 칼럼 등의 객체에 통계정보, 시스템 통계정보 활용
    - 정확한 통계정보 관리는 비용기반 최적화의 중요한 요소
  - 통계정보, DBMS 버전, DBMS 설정 정보에 따라 동일한 SQL 문도 서로 다른 실행계획이 생성될 수 있음.



 - Full Table Scan(FTS)
 - 테이블 내의 모든 데이터를 읽어가면서 조건 검색
 - 고수위 마크(HWM, High Water Mark) 아래의 모든 블록을 읽으므로 시간이 많이 소요됨.
   - 다음의 경우 옵타마이저는 FTS 선택
   - SQL 문에 조건이 존재하지 않는경우 -> 모든 데이터가 답
   - SQL 문 조건에 사용 가능한 인덱스가 없는 경우
   *조건을 만족하는 데이터가 매우 많은 경우(옵티마이저의 선택)
     - 인덱스 스캔은 한 번의 I/O 요청에 한 Block 씩 데이터를 읽음
     - FTS 는 한번의 I/O 요청으로 여러 Block 을 동시에 읽음
   - 병렬처리 방식으로 처리하는 경우
     - FTS 는 여러 Block 을 뭉탱이를 병렬로 읽어올 수 있다.
